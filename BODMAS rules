double evaluateExpression(String exp) {
  exp = remove_constant(exp);//----------------------
  exp = removeBrackets_2(exp);
  exp = removeBrackets_1(exp);
  exp = removeBrackets(exp);
  exp = remove_extra_bracket(exp);
  if(error_occured == true){//--------------------------
    return 0.0;
  }
  char ops[16] = {'p','c','s','o','t','S','C','T','L','l','^','!','/', '*', '-', '+'};//-------------------------
  double nums[30] = {0};
  char symbols[30];
  

  int numCount = 0, symCount = 0;
  String num = "";

  // Parse the expression
  for (int i = 0; i < exp.length(); i++) {
    char ch = exp[i];
    if (isDigit(ch) || ch == '.') {//-------------
      num += ch;
    } else {
      nums[numCount++] = num.toDouble();
      num = "";
      symbols[symCount++] = ch;
    }
  }
  // Push the last number if any
  if (num.length() > 0) {
    nums[numCount++] = num.toDouble();
  }

  // Perform operations in order of precedence: /, *, +, -
  for (int opIndex = 0; opIndex < 16; opIndex++) {
    int i = 0;
    while (i < symCount) {
      if (symbols[i] == ops[opIndex]) {
        double result = 0;
        switch (ops[opIndex]) {
          case '/': result = nums[i] / nums[i + 1]; break;
          case '*': result = nums[i] * nums[i + 1]; break;
          case '+': result = nums[i] + nums[i + 1]; break;
          case '-': result = nums[i] - nums[i + 1]; break;
          case '!': result = factorial(nums[i]) + nums[i+1];break;
          case '^': result = pow(nums[i],nums[i+1]);break;//--------------------
          case 'S': result = (nums[i]==0?sin((radian_state==true?nums[i+1]:radians(nums[i+1]))):nums[i]*sin((radian_state==true?nums[i+1]:radians(nums[i+1]))));break;
          // if(nums[i]==0)result = sin(nums[i+1]);
          // else result = nums[i]*sin(nums[i+1]);
          case 'C': result = (nums[i]==0?cos((radian_state==true?nums[i+1]:radians(nums[i+1]))):nums[i]*cos((radian_state==true?nums[i+1]:radians(nums[i+1]))));break;
          case 'T': result = (nums[i]==0?tan((radian_state==true?nums[i+1]:radians(nums[i+1]))):nums[i]*tan((radian_state==true?nums[i+1]:radians(nums[i+1]))));break;
          case 'l': result = (nums[i]==0?log(nums[i+1]):nums[i]*log(nums[i+1]));break;
          case 'L': result = (nums[i]==0?log10(nums[i+1]):nums[i]*log10(nums[i+1]));break;
          case 'p': result = permutation(nums[i],nums[i+1]);break;
          case 'c': result = combinations(nums[i],nums[i+1]);break;
          case 's': result = (nums[i]==0?asin((radian_state==true?nums[i+1]:radians(nums[i+1]))):nums[i]*asin((radian_state==true?nums[i+1]:radians(nums[i+1]))));break;
          case 'o': result = (nums[i]==0?acos((radian_state==true?nums[i+1]:radians(nums[i+1]))):nums[i]*acos((radian_state==true?nums[i+1]:radians(nums[i+1]))));break;
          case 't': result = (nums[i]==0?atan((radian_state==true?nums[i+1]:radians(nums[i+1]))):nums[i]*atan((radian_state==true?nums[i+1]:radians(nums[i+1]))));break;
        }

        // Replace nums[i] with result and shift others
        nums[i] = result;
        for (int j = i + 1; j < numCount - 1; j++) {
          nums[j] = nums[j + 1];
        }
        numCount--;

        // Remove the used operator
        for (int j = i; j < symCount - 1; j++) {
          symbols[j] = symbols[j + 1];
        }
        symCount--;
        // Stay at same index to recheck current position
      } else {
        i++;
      }
    }
  }
  if(isnan(nums[0]))error_occured = true;//eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee
  answer = nums[0];//----------------------
  return nums[0];
}

double factorial(double number)
{
  double result = 1;
  if(number <= 0)return 1.0;
  for(int i = 1;i<=number;i++)
  {
      result *= i;
  }
  return result;
}

String removeBrackets(String exp) {
  while (exp.indexOf('(') != -1) {
    int close = exp.indexOf(')');
    int open = close;
    while (open >= 0 && exp[open] != '(') open--;
    if (open < 0) break; // Invalid bracket

    String inner = exp.substring(open + 1, close);
    double innerResult = evaluateExpression(inner); // Recursive call
    
    bool leftIsDigit = (open > 0) && isDigit(exp[open - 1]);
    bool rightIsDigit = (close + 1 < exp.length()) && isDigit(exp[close + 1]);
    bool IsTrig = (open > 0) && isSinCosTanLog(exp[open - 1]);//-------------------------
    if(IsTrig && innerResult<0)
    {
      //----------
      double result = 0;
      switch(exp[open - 1]){
        case 'S':result = sin(radian_state==true?innerResult:radians(innerResult));break;
        case 'C':result = cos(radian_state==true?innerResult:radians(innerResult));break;
        case 'T':result = tan(radian_state==true?innerResult:radians(innerResult));break;
        case 'L':result = log10(innerResult);break;
        case 'l':result = log(innerResult);break;
        case 's':result = asin(radian_state==true?innerResult:radians(innerResult));break;
        case 'o':result = acos(radian_state==true?innerResult:radians(innerResult));break;
        case 't':result = atan(radian_state==true?innerResult:radians(innerResult));break;
      }
      if(isnan(result))
      {
        error_occured = true;//eeeeeeeeeeeeeeeeeeeeeeeeeeeeee
        return exp;
      }
      open = open-1;
      leftIsDigit = (open > 0) && isDigit(exp[open - 1]);
      rightIsDigit = (close + 1 < exp.length()) && isDigit(exp[close + 1]);
      innerResult = result;
      
    }//------------------------------------------------
if (leftIsDigit && rightIsDigit) {
  exp = exp.substring(0, open) + "*" + String(innerResult) + "*" + exp.substring(close + 1);
} else if (leftIsDigit) {
  exp = exp.substring(0, open) + "*" + String(innerResult) + exp.substring(close + 1);
} else if (rightIsDigit) {
  exp = exp.substring(0, open) + String(innerResult) + "*" + exp.substring(close + 1);
} else {
  exp = exp.substring(0, open) + String(innerResult) + exp.substring(close + 1);
}
  }
  
  return exp;}
 
String remove_extra_bracket(String exp) {
  char brackets[3] = {'[','{','('};
  char ends[3] = {']','}',')'};
  for(int a = 0;a < 3;a++)
  {  
    for (int i = 1; i < exp.length(); i++) {
      if (isDigit(exp[i - 1]) && exp[i] == brackets[a]) {
        exp = exp.substring(0, i) + "*" + exp.substring(i+1);
        i++; // Skip the '*' we just inserted
      } else if (exp[i - 1] == ends[a] && isDigit(exp[i])) {
        exp = exp.substring(0, i-1) + "*" + exp.substring(i);
        i++; // Skip the '*' we just inserted
      }
    }
  }
    return exp;
}

bool isSinCosTanLog(char ch)
{
  if(ch == 'S'||ch == 'C'||ch == 'T'||ch == 'L'||ch == 'l'||ch == 's'||ch == 'o'||ch == 't')return true;
}


String removeBrackets_2(String exp) {
  while (exp.indexOf('[') != -1) {
    int close = exp.indexOf(']');
    int open = close;
    while (open >= 0 && exp[open] != '[') open--;
    if (open < 0) break; // Invalid bracket

    String inner = exp.substring(open + 1, close);
    double innerResult = evaluateExpression(inner); // Recursive call
    
    bool leftIsDigit = (open > 0) && isDigit(exp[open - 1]);
    bool rightIsDigit = (close + 1 < exp.length()) && isDigit(exp[close + 1]);
    bool IsTrig = (open > 0) && isSinCosTanLog(exp[open - 1]);//-------------------------
    if(IsTrig && innerResult<0)
    {
      //----------
      double result = 0;
      switch(exp[open - 1]){
        case 'S':result = sin(radian_state==true?innerResult:radians(innerResult));break;
        case 'C':result = cos(radian_state==true?innerResult:radians(innerResult));break;
        case 'T':result = tan(radian_state==true?innerResult:radians(innerResult));break;
        case 'L':result = log10(innerResult);break;
        case 'l':result = log(innerResult);break;
        case 's':result = asin(radian_state==true?innerResult:radians(innerResult));break;
        case 'o':result = acos(radian_state==true?innerResult:radians(innerResult));break;
        case 't':result = atan(radian_state==true?innerResult:radians(innerResult));break;
      }
      if(isnan(result))
      {
        error_occured = true;//eeeeeeeeeeeeeeeeeeeeeeeeeeeeee
        return exp;
      }
      open = open-1;
      leftIsDigit = (open > 0) && isDigit(exp[open - 1]);
      rightIsDigit = (close + 1 < exp.length()) && isDigit(exp[close + 1]);
      innerResult = result;
      
    }//------------------------------------------------
if (leftIsDigit && rightIsDigit) {
  exp = exp.substring(0, open) + "*" + String(innerResult) + "*" + exp.substring(close + 1);
} else if (leftIsDigit) {
  exp = exp.substring(0, open) + "*" + String(innerResult) + exp.substring(close + 1);
} else if (rightIsDigit) {
  exp = exp.substring(0, open) + String(innerResult) + "*" + exp.substring(close + 1);
} else {
  exp = exp.substring(0, open) + String(innerResult) + exp.substring(close + 1);
}
  }
  
  return exp;}


String removeBrackets_1(String exp) {
  while (exp.indexOf('{') != -1) {
    int close = exp.indexOf('}');
    int open = close;
    while (open >= 0 && exp[open] != '{') open--;
    if (open < 0) break; // Invalid bracket

    String inner = exp.substring(open + 1, close);
    double innerResult = evaluateExpression(inner); // Recursive call
    
    bool leftIsDigit = (open > 0) && isDigit(exp[open - 1]);
    bool rightIsDigit = (close + 1 < exp.length()) && isDigit(exp[close + 1]);
    bool IsTrig = (open > 0) && isSinCosTanLog(exp[open - 1]);//-------------------------
    if(IsTrig && innerResult<0)
    {
      //----------
      double result = 0;
      switch(exp[open - 1]){
        case 'S':result = sin(radian_state==true?innerResult:radians(innerResult));break;
        case 'C':result = cos(radian_state==true?innerResult:radians(innerResult));break;
        case 'T':result = tan(radian_state==true?innerResult:radians(innerResult));break;
        case 'L':result = log10(innerResult);break;
        case 'l':result = log(innerResult);break;
        case 's':result = asin(radian_state==true?innerResult:radians(innerResult));break;
        case 'o':result = acos(radian_state==true?innerResult:radians(innerResult));break;
        case 't':result = atan(radian_state==true?innerResult:radians(innerResult));break;
      }
      if(isnan(result))
      {
        error_occured = true;//eeeeeeeeeeeeeeeeeeeeeeeeeeeeee
        return exp;
      }
      open = open-1;
      leftIsDigit = (open > 0) && isDigit(exp[open - 1]);
      rightIsDigit = (close + 1 < exp.length()) && isDigit(exp[close + 1]);
      innerResult = result;
      
    }//------------------------------------------------
if (leftIsDigit && rightIsDigit) {
  exp = exp.substring(0, open) + "*" + String(innerResult) + "*" + exp.substring(close + 1);
} else if (leftIsDigit) {
  exp = exp.substring(0, open) + "*" + String(innerResult) + exp.substring(close + 1);
} else if (rightIsDigit) {
  exp = exp.substring(0, open) + String(innerResult) + "*" + exp.substring(close + 1);
} else {
  exp = exp.substring(0, open) + String(innerResult) + exp.substring(close + 1);
}
  }
  
  return exp;}

String remove_constant(String exp)
{
  char symbol[4] = {'y','A','P','e'};
  for(int j = 0;j < 4;j++)
  {
      if(exp.indexOf(symbol[j])!=-1)
    {
      double result=0;
      int i = exp.indexOf(symbol[j]);
      bool isleftDigit = (i > 0) && (isDigit(exp[i-1]));
      bool isRightDigit = (i+1 < exp.length()) && (isDigit(exp[i+1]));
      if(symbol[j]=='A')result = answer;
      else if(symbol[j]=='P')result = PI;
      else if(symbol[j]=='e')result = 2.71828;
      else if(symbol[j]=='y')result = random(1000);
      if(isleftDigit && isRightDigit)
      {
        exp = exp.substring(0,i) + "*" + String(result) + "*" + exp.substring(i+1);
      }
      else if(isleftDigit)
      {
        exp = exp.substring(0,i) + "*" + String(result) + exp.substring(i+1);
      }
      else if(isRightDigit)
      {
        exp = exp.substring(0,i) + String(result) + "*" + exp.substring(i+1);
      }
      else
      {
        exp = exp.substring(0,i) + String(result) + exp.substring(i+1);
      }
    }
  }
 
  return exp;
}

double permutation(int n,int r)
{
  double result = (factorial(n))/(factorial(n-r));
  return result;
}
double combinations(int n,int r)
{
  double result = permutation(n,r);
  result = result/factorial(r);
  return result;
}

